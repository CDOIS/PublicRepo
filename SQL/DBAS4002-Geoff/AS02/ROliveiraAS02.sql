USE [Chinook];
GO;
--1.	A new column called Paid should be added to the existing Invoice table. It will be marked as True only when an invoice has been fully paid. When a new invoice is created, the new field should always be set to False until full payment has been received.
ALTER TABLE INVOICE
ADD Paid BIT DEFAULT(0)  -- Create new Paid column with default value False
GO

--2.	A new table called InvoicePayment will be added. See ERD*.
DROP TABLE IF EXISTS InvoicePayment;
CREATE TABLE InvoicePayment (    --CREATE TABLE WITH SPECIFIED ATTRIBUTES.
	PaymentID INT IDENTITY,
	InvoiceID INT NOT NULL,
	CustomerID INT NOT NULL,
	PaymentDate DATETIME NOT NULL,
	Amount NUMERIC(10,2) NOT NULL,
	CONSTRAINT PK_Payment PRIMARY KEY (PaymentID),
	CONSTRAINT FK_InvoiceID FOREIGN KEY (InvoiceID)
	REFERENCES Invoice(InvoiceID),
	CONSTRAINT FK_CustomerID FOREIGN KEY (CustomerID)
	REFERENCES Customer(CustomerID)
	);
GO

--3.	Four new procedures should be added to the database. 
--a.	Each procedure must use transactions where appropriate and include basic error handling. If PART OF THE PROCEDURE FAILS, the ENTIRETY of its tasks should be reverted.
--b.	Proc 1: A procedure named uspAddNewInvoice, which will be used to add new invoice records to the Invoice table. Note: For this assignment, an Invoice will only ever have a single InvoiceLine item associated with it. This proc will receive all values for the new Invoice and its line item and add them as new, related records to the Invoice and InvoiceLine tables. The Invoice Date should be auto-generated by the system, and the Invoice Total field should be calculated (Price * Quantity) instead of passed as a parameter.

CREATE OR ALTER PROCEDURE uspAddNewInvoice (@TrackID INT,								   
								   @Quantity INT,								   
								   @CustomerID INT)
AS
BEGIN --Begin Procedure
	BEGIN TRAN -- Begin Transaction
		BEGIN TRY -- Begin error handling
			--Declaring and assigning values to variables
			DECLARE @InvoiceDate DATETIME;
			SELECT @InvoiceDate = SYSDATETIME(); -- Setting the actual sysdate

			DECLARE @NewInvoice INT;
			SELECT @NewInvoice = (COUNT(Invoice.InvoiceId)+1) FROM Invoice;

			DECLARE @UnitPrice NUMERIC(10,2);
			SELECT @UnitPrice = Track.UnitPrice FROM Track WHERE @TrackID = Track.TrackId;

			DECLARE @Total NUMERIC(10,2);
			SET @Total = @UnitPrice * @Quantity; --Calculating the value from the data;

			DECLARE @BillingAddress VARCHAR(70);
			SELECT @BillingAddress = Customer.Address FROM Customer WHERE @CustomerID = Customer.CustomerId;

			DECLARE @BillingCity VARCHAR(40);
			SELECT @BillingCity = Customer.City FROM Customer WHERE @CustomerID = Customer.CustomerId;

			DECLARE @BillingState VARCHAR(40);
			SELECT @BillingState = Customer.State FROM Customer WHERE @CustomerID = Customer.CustomerId;

			DECLARE @BillingCountry VARCHAR(40);
			SELECT @BillingCountry = Customer.Country FROM Customer WHERE @CustomerID = Customer.CustomerId;

			DECLARE @BillingPostalCode VARCHAR(10); 
			SELECT @BillingPostalCode = Customer.PostalCode FROM Customer WHERE @CustomerID = Customer.CustomerId;									
		
			INSERT INTO Invoice(CustomerId,  --Create invoice record
								InvoiceDate, 
								BillingAddress, 
								BillingCity, 
								BillingState, 
								BillingCountry, 
								BillingPostalCode, 
								Total)

					VALUES (@CustomerID,
							@InvoiceDate,
							@BillingAddress,
							@BillingCity,
							@BillingState,
							@BillingCountry,
							@BillingPostalCode,
							@Total)			

			INSERT INTO InvoiceLine(TrackId, --Create InvoiceLine record
									InvoiceId,
									UnitPrice,
									Quantity)

						VALUES (@TrackID,
								@NewInvoice,
								@UnitPrice,
								@Quantity)
		END TRY
		BEGIN CATCH
			PRINT ('You GOT ERROR~! CALL DB ADMIN');
			ROLLBACK
		END CATCH
	COMMIT
END;
GO;


--c.	Proc 2: A procedure named uspAddInvoicePayment, which will be used to add a new record to the new InvoicePayment table. Moving forward, this proc will be used to process new payment entries. The Payment Date should be auto-generated by the system.

CREATE OR ALTER PROCEDURE uspAddInvoicePayment (@InvoiceID INT,
									   @Amount NUMERIC (10,2))
AS
BEGIN
	BEGIN TRAN
		BEGIN TRY
			-- Declaring and assigning values to the variables, according to the parameters
			DECLARE @PaymentDate DATETIME;
			SELECT @PaymentDate = SYSDATETIME();
			DECLARE @CustomerID INT;
			SELECT @CustomerID = Invoice.CustomerId FROM Invoice WHERE Invoice.InvoiceId = @InvoiceID;			
			INSERT INTO InvoicePayment(InvoiceID,  --Create respective InvoicePayment record
								CustomerID, 
								Amount, 
								PaymentDate)

					VALUES (@InvoiceID,
							@CustomerID,
							@Amount,
							@PaymentDate)			
		END TRY
		BEGIN CATCH
			PRINT ('You GOT ERROR~! CALL DB ADMIN');
			ROLLBACK
		END CATCH
	COMMIT
END;
GO;

--d.	Proc 3: A procedure called uspRunInvoices. The intent of this procedure is to be a one-time proc that will create invoice payment records for all existing records. (Moving forward, Invoices and Payments will use the other new stored procs.) This procedure will assume all existing Invoice have been paid in full. It will go through every existing Invoice record and use data from the existing Invoice records to create new InvoicePayment records. After gathering the appropriate data for an Invoice record, this procedure will call the uspAddInvoicePayment procedure to add the new Payment records.

CREATE OR ALTER PROCEDURE uspRunInvoices
AS
BEGIN
	BEGIN TRAN
		BEGIN TRY
			-- Declaring and assigning values to the variables, according to the parameters
			DECLARE @numInvoices INT;
			SELECT @numInvoices = COUNT(Invoice.InvoiceId) FROM Invoice;
			DECLARE @counter INT;
			SET @counter = 1;
			--While Loop to iterate through all the Invoice Records
			WHILE (@counter <= @numInvoices) 
				BEGIN
				-- Setting the Amount paid equals to the total for each invoice
				DECLARE @Amount NUMERIC(10,2);
				SELECT @Amount = Invoice.Total from Invoice WHERE Invoice.InvoiceId = @counter;
				-- Running procedure to create the respective InvoicePayment
				EXEC uspAddInvoicePayment @counter, @amount; 
				SET @counter += 1;
				END
		END TRY
		BEGIN CATCH
			PRINT ('You GOT ERROR~! CALL DB ADMIN');
			ROLLBACK
		END CATCH
	COMMIT
END;
GO;

--e.	Proc 4: A procedure called uspCheckPaidInvoices, which will iterate through every Invoice record and compare it to its associated Payment record. If the amount in both records is the same, the procedure will update the Paid field in the Invoice table to True.

CREATE OR ALTER PROC uspCheckPaidInvoices 
AS
BEGIN
	BEGIN TRAN
		BEGIN TRY
			-- Declaring and assigning values to the variables, according to the parameters
			DECLARE @counter INT;
			SET @counter = 1;			
			DECLARE @maxInvoice INT;
			SELECT @maxInvoice = COUNT(Invoice.InvoiceId) FROM Invoice;
			-- Loop to iterate through each of the Invoices;
			WHILE (@counter <= @maxInvoice)
				BEGIN
					--Declaring and assignin values to specific record variables;
					DECLARE @totalBill NUMERIC(10,2);
					DECLARE @totalAmount NUMERIC(10,2);
					SELECT @totalBill = Invoice.Total FROM Invoice 
						WHERE Invoice.InvoiceId = @counter;
					SELECT @totalAmount =InvoicePayment.Amount FROM InvoicePayment 
						WHERE InvoicePayment.InvoiceID = @counter;
					--Updating Invoice record, if the requirement is met - If the Invoice is Paid in full
					UPDATE Invoice SET Paid = 1 
						WHERE @totalAmount >= @totalBill and InvoiceId = @counter;
					
					SET @counter += 1;
				END
		END TRY
		BEGIN CATCH
			PRINT ('You GOT ERROR~! CALL DB ADMIN');
			ROLLBACK;
		END CATCH
	COMMIT;
END;
GO

--Your testing script should include:
--•	A statement to add a new Invoice/InvoiceLine record (only one InvoiceLine record is required), using your uspAddNewInvoice procedure.
BEGIN TRAN
	USE Chinook
	DECLARE @totalinvoicesb4proc INT;
	SELECT @totalinvoicesb4proc = COUNT(Invoice.InvoiceId) FROM Invoice;
	PRINT ('Total invoices before addProcedure.');
	PRINT (@totalinvoicesb4proc);

	EXEC uspAddNewInvoice 20, 5, 30;

	DECLARE @totalinvoicesAfterproc INT;
	SELECT @totalinvoicesAfterproc = COUNT(Invoice.InvoiceId) FROM Invoice;
	PRINT ('Total invoices after addProcedure.');
	PRINT (@totalinvoicesAfterproc);
COMMIT;
GO;

--•	A statement to add a new invoice payment for the new Invoice added in Test 1, using your uspAddInvoicePayment procedure.
BEGIN TRAN
	USE Chinook
	DECLARE @totalinvoicePaymentb4proc INT;
	SELECT @totalinvoicePaymentb4proc = COUNT(InvoicePayment.PaymentID) FROM InvoicePayment;
	PRINT ('Total InvoicePayment before addProcedure.');
	PRINT (@totalinvoicePaymentb4proc);
	EXEC uspAddInvoicePayment 413, 100.00;
	DECLARE @totalinvoicePaymentAfterproc INT;
	SELECT @totalinvoicePaymentAfterproc = COUNT(InvoicePayment.PaymentID) 
																		FROM InvoicePayment;
	PRINT ('Total InvoicePayment after addProcedure.');
	PRINT (@totalinvoicePaymentAfterproc);
COMMIT;
GO;
--•	A statement to revert ALL Invoice records to unpaid status.
BEGIN TRAN
	USE Chinook
	UPDATE Invoice
		SET Paid = 0;
COMMIT;
GO
--•	A statement to remove all existing records from the InvoicePayment table.
BEGIN TRAN
	USE Chinook
	DELETE FROM InvoicePayment;
COMMIT;
GO
--•	A statement to re-create all InvoicePayment records, using your uspRunInvoices procedure.
BEGIN TRAN
	EXEC uspRunInvoices;
COMMIT;
GO
--•	A statement to re-set all applicable Invoices to Paid or not, using your uspCheckPaidInvoices procedure.
BEGIN TRAN
	EXEC uspCheckPaidInvoices;
COMMIT;
GO
			

